{"pages":[],"posts":[{"title":"一份不完全的数据可视化入门指南","text":"1. 如何快速上手数据可视化？1.【FreeCodeCamp】https://www.freecodecamp.cn/home (学习Html/Css/JavaScript) 2.【Echarts.js】https://www.echartsjs.com/zh/index.html 3.【D3】https://d3js.org/ 4.【更多的工具总结】 https://zhuanlan.zhihu.com/p/24089938 2.有哪些值得借鉴的优秀的数据可视化设计作品？【使用Tableau Public 制作的优秀作品】https://public.tableau.com/zh-cn/gallery/?tab=viz-of-the-day&amp;type=viz-of-the-day 【使用Echarts制作的优秀作品】 https://gallery.echartsjs.com/explore.html#sort=ranktimeframe=allauthor=all 【信息之美获奖作品】https://www.informationisbeautifulawards.com/ 【数据可视化领域的五大趋势】https://baijiahao.baidu.com/s?id=1614710364563883354&amp;wfr=spider&amp;for=pc 【一位自由数据可视化设计师（ Nadieh Bremer ）的作品集】https://www.visualcinnamon.com/portfolio/ 3.数据可视化的学术研究发展情况？CCF A类会议/刊物【IEEE Visualization Conference (IEEE VIS)】http://dblp.uni-trier.de/db/conf/visualization/index.html 【IEEE Transactions on Visualization and Computer Graphics(TVCG)】 http://dblp.uni-trier.de/db/journals/tvcg/ 【ACM Knowledge Discovery and Data Mining （SIGKDD）】http://dblp.uni-trier.de/db/conf/kdd/ 国内的实验室/学者【北京大学，袁晓如】 http://vis.pku.edu.cn/wiki/ 【浙江大学，陈为】 http://www.cad.zju.edu.cn/home/vagblog/ 【同济大学，曹楠】http://www.nancao.org/ 【清华大学，刘世霞】 http://www.shixialiu.com/ 【四川大学，朱敏】 http://scuvis.org/ 4.有哪些书籍可以进行学习？《Knowledge Is Beautiful》https://book.douban.com/subject/11650561/ 《数据可视化》 https://book.douban.com/subject/25760272/ 《数据可视化(40位数据设计师访谈录)》 https://book.douban.com/subject/27049704/ 5.相关的比赛？【China Vis 挑战赛】 http://www.chinavis.org/2019/challenge.html 【Kaggle】 http://kaggle.com/ 【天池大数据比赛】https://tianchi.aliyun.com/competition/gameList/activeList","link":"/2019/10/13/%E4%B8%80%E4%BB%BD%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"},{"title":"文档主题建模","text":"对于一篇文章来说，分析它的主题能够达到理解文本的效果。主题建模就是通过在文档集合里面学习、识别和提取主题的过程。对于一篇文章 或者说一个文档来说，它包含着多个主题，而如何去区分不同的主题，是通过主题下面包含的多个单词来进行分析，我们能够将文档转化为一个数值向量，每一个维度对应一个主题。 作用 分类文档 （比如说不同领域的新闻：科技、金融、体育新闻。通过对新闻的主题建模，能够将文本按照主题来归类） 检索（当用户输入关键字的时候，就能够确认检索的文本的主题，从而在数据库进行匹配，最终返回相符的文本） 文本模型的可交换性目前，大多数文本模型都基于“bag-of-words”的假设，即 1.一篇文档内N个词之间的顺序可以随意互换，不影响建模过程 2.一个语料库内M个文档可以随意互换顺序，哪个文档在前哪个文档在后都无所谓。这两个性质合称为文本模型的可交换性 四种流行的用于主题建模的算法1.LSA(Latent semantic analysis)LSA的核心思想就是将我们所拥有的文档-术语矩阵分解成相互独立的文档-主题矩阵和主题-术语矩阵。词和文档是用向量来表示的，通过向量之间的关系，来判断词与词之间 或者文档与文档之间的关系。 2.pLSApLSA，即概率潜在语义分析，采取概率方法替代 SVD 以解决问题。其核心思想是找到一个潜在主题的概率模型，该模型可以生成我们在文档-术语矩阵中观察到的数据。 3.LDA将狄利克雷视为「分布的分布」。本质上，它回答了这样一个问题：「给定某种分布，我看到的实际概率分布可能是什么样子？」 一篇文档，可以看成是一组有序的词的序列。从统计学角度来看，文档的生成可以看成是上帝抛掷骰子生成的结果，每一次抛掷骰子都生成一个词汇，抛掷N词生成一篇文档。在统计文本建模中，我们希望猜测出上帝是如何玩这个游戏的，这会涉及到两个最核心的问题：上帝都有什么样的骰子；上帝是如何抛掷这些骰子的；第一个问题就是表示模型中都有哪些参数，骰子的每一个面的概率都对应于模型中的参数；第二个问题就表示游戏规则是什么，上帝可能有各种不同类型的骰子，上帝可以按照一定的规则抛掷这些骰子从而产生词序列。 4.lda2vec社交媒体如微博、脸书上也会有大量值得研究的文本，这些文本规模大、更新速度更快而且语义信息不丰富、噪声高。传统的pLSA和LDA模型泛化能力弱、主题词可解释性差、分类准确性低。 文档向量表示随着word2vec模型的提出和深度学习的发展,近年来出现了很多相关研究成果。以LDA为代表的主题模型认为文档的生成是不同主题混合的结果;神经网络模型习惯于将文档表示为稠密向量。如果结合前者覆盖范围广和后者维度低的特点生成新的模型,可以做到快速检测,同对隐含语义的解释也会更好。lda2vec模型就是基于这一思想提出的。","link":"/2019/11/26/%E6%96%87%E6%A1%A3%E4%B8%BB%E9%A2%98%E5%BB%BA%E6%A8%A1/"},{"title":"《JavaScript&jQuery 交互式Web前端开发》（一）","text":"一、基础知识1.什么是脚本？如何创建？脚本是一系列的指令，计算机执行后可达成目标 2.计算机如何融入它周围的世界中？window对象window对象的location属性告诉你当前页面的URL document对象属性title属性 告诉你web页面上title标签中的标题是什么lastModified属性 告诉你页面最后被修改的日期URL属性 事件load 页面和页面上的元素完成加载时click 用户在页面上点击鼠标时keypress 用户按下某个按键时 方法write() 向document中添加新的内容getElementById() 使用元素的id属性访问一个元素 浏览器如何看待web页面？1.以HTML代码方式接收页面2.创建页面模型 将模型存储在内存中3.使用渲染引擎将页面显示到屏幕上渲染引擎处理css规则 应用到对用的元素上4.浏览器中的脚本引擎解释js 翻译成对用的指令 然后被执行 （js 解释型编程语言 每一行代码被以此翻译 然后执行） 3.如何为Web页面编写一段脚本？内容层 html展现层 css行为层 javascript 渐进式增强web页面的创建方法1.仅有HTML2.HTML+CSS3.HTML+CSS+JS 使用对象和方法document.write('Good Afternoon!');document对象表示整个web页面 所有web浏览器都实现了这个对象document对象中的方法和属性被称为对象的成员 二、JavaScript基础指令变量命名必须以字母，$或_开头 数组数组里的值可以是不同类型的 三、函数、方法与对象声明函数function sayHello(){ document.write(&apos;hello!&apos;); }匿名方法和函数表达式匿名函数：没有名字的函数 var area=function(width,height){ return width*height; } var size=area(3,4)解释器到达第一句话时函数不会执行 立即调用函数表达式IIFEvar area=（function(){ var width=3; var height=2; return width*height; ()) } var size=area(3,4)最后一对括号告诉解释器马上调用此函数分组的括号确保解释器将这作为一个表达式对待 使用匿名函数与IIFE的时机1.当函数被调用时作为实参2.用于为对象的属性赋值3.用于事件处理程序和监听器4.防止两段脚本中因使用同样的变量名而产生冲突5.IIFE通常被用作一组代码的封装器 在此匿名函数中声明的任何变量能够非常有效地保护变量 变量作用域全局变量在页面载入浏览器地时候就进驻内存全局变量比局部变量占用更多的内存 增加命名冲突的风险 对象创建对象：字面量语法var hotel={ name:&apos;Quay&apos;, rooms:40, booked:25, checkAvailablity:function(){ return this.rooms-this.booked; } };访问对象访问对象的属性或方法 用点符号或方括号 创建对象：构造函数语法var hotel=new Object(); hotel.name=&apos;Quay&apos; hotel.rooms=40; hotel.booked=25; hotel.checkAvailability=function(){ return this.rooms-this.booked; };修改对象使用点符号或方括号适用于字面量语法或构造函数语法创建的对象 删除对象delete hotel.name删除对象的属性 创建很多对象：构造函数语法function Hotel(name,rooms,booked){ this.name=name; this.rooms=rooms; this.booked=booked; this.checkAvailability=function(){ return this.rooms-this.booked; }; } var quayHotel=new Hotel(&apos;Quay&apos;,40,25);数组和对象相关关系 内置对象浏览器附带了一系列内置的对象 代表当前窗口中网页的一些内容 这些内置对象的行为类似于创建交互式网页的工具。 1.浏览器对象模型（BOM)包含一系列表示当前窗口或标签的对象 比如浏览历史以及设备屏幕。 window //当前浏览器窗口或标签 document //窗口或标签 history //浏览过的网页 location //当前页的URL navigator //浏览器的信息 screen //设备的显示信息 window.alert() //创建含有消息的对话框window.open() //在新的浏览器窗口打开参数中指定的URL 2.文档对象模型（DOM)使用对象为当前页的创建展现，为页面中的每个元素创建一个新对象。 document.title //当前文档的标题document.lastModified //文档最后一次被修改的日期document.URL //返回包含当前文档URL的字符串document.domain //返回当前文档的域document.getElementById() //返回于ID属性值匹配的元素document.creatElement() //创建新元素document.creatTextNode() //创建新的文本节点 3.全局JavaScript对象不构成模型 是一些独立的对象StringNumberBooleanDate //展现和处理日期Math //处理数字和计算RegEx //匹配文本的字符串模式 数字对象isNaN() //检查值是否时数字toFixed() //将特定的数字四舍五入至指定小数位数 Math对象Math.PI //返回pi值Math.random() //获取一个[0,1)的随机数 获取1-10的随机数 var randomNum=math.floor((Math.random*10)+1);Date对象var today=new Date();//创建一个Date对象getSecond() setSecond() 返回/设置秒 四、判断和循环强制类型转换和弱类型(‘1’&gt;0) 字符串1会被转化成数字1 JS 弱类型语言推荐用严格等于和严格不等于=== 和 ！== 每个值都可以被当作true或false真值：true、非零数字、有内容的字符串、数字运算结果非零假值： false、数字零、空字符串、NAN、没有被赋值的变量 检测相等和存在对象或数组可以被视为真值 判断页面中的元素是否存在 if(document.getElementById(&apos;header&apos;)){ //found:do something } else { //not found: do something else; }","link":"/2019/05/19/%E3%80%8AJavaScript&jQuery%20%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"《JavaScript&jQuery 交互式Web前端开发》（二）","text":"四、文档对象模型浏览器加载web 创建页面模型 这个模型被称为DOM树 被保存在浏览器的内存中 四种节点 文档节点 元素节点 属性节点 文本节点 使用DOM树访问并更新DOM树的两个步骤：1.定位到于需要操作的元素所对应的节点2.使用它的文本内容、子元素或属性 1.访问元素getElementById()querySelector() //使用CSS选择器getElementByClassName() //选择所有在class中使用了特定值的元素getElementByTagName() //选择所有使用了指定标记的元素querySelectorAll() //使用CSS选择器来选择所有匹配的元素parentNode //当前节点的父节点previousSibling/nextSibling //前一个或后一个兄弟节点firstChild/lastChild //当前节点的第一个或最后一个子节点 2.操作元素nodeValue 这个属性允许访问或修改文本节点中的内容innerHTML 这个属性可以访问子元素和文本内容textContent 这个属性仅访问文本内容createElement() 创建节点createTextNode()appendChild() 将节点添加到树中removeChild() 从树中移除节点className/id 可以获取更新class和id的属性hasAttribute() 检查属性是否存在getAttribute() 获取属性值setAttribute() 更新属性值removeAttribute() 移除属性值 3.访问元素DOM查询可能返回一个元素 也可能返回一个NodeList 节点的集合 4.返回多个元素的DOM查询length NodeList中一共有多少个项item() 方法：返回NodeList中特定的节点 需要在小括号中指定编号 5.重用NodeList动态NodeList 脚本更新页面之后，NodeList也同样会更新 静态的话 NodeList不会被更新 不会反映脚本所做的修改 getElementBy开头的方法都会返回动态NodeListquerySelector开头的方法会返回静态NodeList var elements=getElementByTagName(&apos;h1&apos;); if(elements.length&gt;=1){//检查nodelist至少包含一个节点 var firstItem=elements.item(0);//item()方法 var secondItem=elements[1];//数组语法 }数组语法的速度更快 更推荐使用 6.遍历DOM有些浏览器会在元素之间添加一个文本节点 不管它之间是不是真的有空白解决这一问题的方法 使用jQuery库 使用NodeValue属性获取和更新文本节点var itemTwo=document.getElementById(&apos;two&apos;); var elText=itemTwo.firstChild.nodeValue; elText=elText.replace(&apos;pine nuts&apos;,&apos;kale&apos;); itemTwo.firstChild.nodeValue=eltext;使用textContent和innerText获取和更新文本&lt;li id=&quot;one&quot;&gt;&lt;em&gt;fresh&lt;/em&gt;figs&lt;/li&gt;获取li元素中的文本 用textContent返回fresh figs同样可以使用这个属性来更新元素的内容 innerText应避免使用 FireFox不支持不会返回css隐藏的内容 需要考虑布局规则来判断元素的可见性 在获取文本内容的速度要比textContent慢 使用innerHTML获取和更新文本var firstItem=document.getElementById(&apos;one&apos;); var itemContent= firstItem.innerHTML; firstItem.innerHTML=&apos;&lt;a href=\\&quot;http://example.org\\&quot;&gt;&apos;+itemContent+&apos;&lt;/a&gt;&apos;;itemContent中包含如下字符串&lt;em&gt;fresh&lt;/em&gt; figs浏览器会把字符串中包含的任何元素都添加到DOM树中","link":"/2019/06/27/%E3%80%8AJavaScript&jQuery%20%E4%BA%A4%E4%BA%92%E5%BC%8FWeb%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E3%80%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"从停机问题到不可知论","text":"你被关在在一个房间里，房间里挤满了很多台机器。对于你眼前的一台机器P，有一个小矮人坐在机器前，不断地向机器里敲打着序列，这时机器大声地喊了一句”hello world!”，说明条件满足了 。如果机器没有动静，说明输入的序列并不满足让它大喊的条件。对于每一台机器来说，它们满足的条件各不相同。 我告诉你，你的任务是，造出一台超级机器，这样你才能够出去。这台机器我要求对于房间里任意的一台机器和对应的输入，如果这台机器能够喊出”hello world”， 那么超级机器就会说”yes”, 如果这台机器不能”hello world”， 那么超级机器就会说”no”。 这看起来是个很简单的任务，因为超级机器只需要判断其他机器能不能喊”hello world”就可以了。这时候，我又对你提出了新的要求：”如果超级机器判断的机器没有喊’hello world’ ，那就让这台超级机器代替它喊一句’hello world’。” 好像和之前的任务也没什么差别，只是改变了喊话的内容而已。 现在我告诉你，对于某一台机器来说，你输入的序列，也完全可以是那台机器本身。什么意思呢，其实说到底，这里说的机器并不是实际存在的东西，而是一串序列，这听上去有一点恐怖，你能够把机器编成一串序列，让小矮人把这个序列敲到机器里。 总之，小矮人们不太情愿地把这个序列敲进了机器，对于机器接下来会怎么样，小矮人也不清楚。但这时候你会发现，有些机器发出了”hello world”， 有些机器十分安静。说”hello world” 或是不说，就这两种结果。 对于超级机器来说，你大概发现了，这台机器至少要有两个输入，也就是说，一个小矮人输入的是你要判断能不能发出”hello world” 的那台机器（所代表的序列P），而另一个小矮人要输入你要输入到待判断的机器里的那个序列I。 但是现在我说，没必要再找两个小矮人，直接让你来，输入的序列就是机器代表的序列，不需要输入I了，机器也不需要有两个输入口，一个就够了。相当于说，之前说的两个输入，都是机器代表的序列P。你会输入两次机器代表的序列P，但是，鉴于这台超级机器只有一个输入，那么当你第一次输入P时，这台只由你控制的机器也会有一个输出，也就是说，当你输入P的时候，这台超级机器也有可能因为满足它自身的条件而大喊”hello world”。 我想你可能也想不出来这样的机器要怎么做，但总之，我指着角落的一台机器，告诉你，其实那台机器就是超级机器。我让你过去，并且我告诉了你超级机器所代表的序列。 “输入吧。” 我说。 你开始敲打超级机器代表的序列，就像把超级机器自己塞进了自己的输入口里。 但最终你发现了，我骗了你，那台机器根本就不是超级机器。 如果这台超级机器，输入自己的序列，喊出了”hello world”， 那么根据最开始定义的规则，它会喊出”yes”, 而如果这台超级机器输入自己的序列并没有发出声音，按照定义，它输入的机器没有喊出”hello world”的时候，它会代替输入的机器，喊出”hello world”。 这根本不可能，超级机器根本没办法造出来。就是这样，你没法逃出房间。 今天计算理论讲了停机问题，感觉非常有意思，于是写了一个小故事，尽可能简单地解释出这一构造的巧妙性，但是可能会有交代不清的地方，欢迎指正~ 另外，关于停机问题，老师还扯到了很多有意思的东西，非常之”哲学”。 比如说，如果故事里的机器是杀毒软件的话，其实可以发现，杀毒软件是不能够检测出所有的病毒的，因为它不能知道自己是不是就是病毒（细思极恐）。而且停机问题的推导其实涉及到了一种自我指涉的矛盾。说到”自我”，其实就会发现，按照这样的逻辑，一个人是无法完全认识自己的，或者说一个人是无法完全理解自身的。 如果故事里的机器是我们的脑子，用我们的脑子去研究我们的脑子，其实就会有不能够认识到的地方。脑子是研究的主体，也是研究的客体；就像机器作为程序，但同时又作为程序的输入，而这时候你是不能认识到机器的输出的，所以你其实不能认识到这种脑子研究脑子的正确性甚至是可行性。所以说这就某种程度上支持了不可知论。","link":"/2019/04/22/%E4%BB%8E%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98%E5%88%B0%E4%B8%8D%E5%8F%AF%E7%9F%A5%E8%AE%BA/"},{"title":"数字人文&人文计算","text":"上周二和综英老师聊了一下关于计算机怎么和文学之类结合，然后获得一枚关键词”数字人文”，遂找了几篇综述、文章以及YouTube的视频大概学了一下。发现真的是，自己瞎想怎么结合、怎么交叉，抵不过老师直接说一个研究分支来得快得多。 下面把记录下来，方便自己，也能方便别人叭：） 这个应该会不断更新。 各种实验室/组织 武汉大学数字人文研究中心 台湾”中央研究院”数位文化中心 北京大学kvision实验室 清华大学自然语言处理与社会人文计算实验室 数字人文组织联盟 可视化平台作品1.北大Kvision 在数字人文方面主要的成果： “中国历史人物生卒迁徙”可视化平台 “中国古代学术师承”可视化平台 “宋代学术传承”知识图谱 有意思的论文&amp;文章 文学经典的大数据分析与文化增殖 人文学科与社会科学的分野 Youtube视频 An Introduction to Digital Humanities","link":"/2019/04/23/%E6%95%B0%E5%AD%97%E4%BA%BA%E6%96%87&%E4%BA%BA%E6%96%87%E8%AE%A1%E7%AE%97/"},{"title":"FCC-Front End-Basic Javascript-资料整理","text":"因为做辛卫的作业迅速入门js,但是还是感觉不太清晰，于是上fcc补了这部分，整理了一些笔记，以供参考。 当 JavaScript 中的变量被声明的时候，程序内部会给它一个初始值 undefined。当你对一个值为 undefined 的变量进行运算操作的时候，算出来的结果将会是NaN，NaN 的意思是 “Not a Number”。当你用一个没有定义的变量来做字符串连接操作的时候，它会如实的输出”undefined”。 var a=&quot;I am a string&quot;; 在 JavaScript 中所有的变量都是大小写敏感的。这意味着你要区别对待大写字母和小写字母。MYVAR与MyVar和myvar 是截然不同的变量。这就有可能导致多个截然不同的变量却有着有相似的名字。正是由于以上原因所以强烈地建议你, 不要 使用这一特性。（以免给自己带来麻烦）最佳实践使用 驼峰命名法 来书写一个 Javascript 变量，在 驼峰命名法 中，变量名的第一个单词的首写字母小写，后面的单词的第一个字母大写。举个栗子：var someVariable;var anotherVariableName;var thisVariableNameIsTooLong; 在 JavaScript 中的 字符串 要用单引号或双引号来包裹它，只要你在开始和结束都使用相同类型的引号，单引号和双引号的功能在JavaScript中是相同的。 在 JavaScript 中，当 + 操作符与 字符串 一起使用的时候，它被称作连接 操作符。你可以通过和其他字符串连接 来创建一个新的字符串。举个例子：'My name is Alan,' + ' I concatenate.'注意空格。连接操作不会添加两个字符串之外的空格，所以想加上空格的话，你需要自己在字符串里面添加。 你可以通过在字符串变量或字符串后面写上 .length 来获得字符串变量 字符串 值的长度。 Use Bracket Notation to Find the First Character in a String[]叫中括号，{}叫大括号，()叫小括号。JavaScript中只有字符串类型，没有字符类型。那么如何获取到字符串中的某个字符呢？我们通过[索引] 来获得对应的字符。大多数现代编程语言，如JavaScript，不同于人类从1开始计数。它们是从0开始计数，这被称为 基于零 的索引。例如, 在单词 “Charles” 中索引0上的字符为 “C”，所以在 var firstName = “Charles” 中，你可以使用 firstName[0] 来获得第一个位置上的字符。 Understand String Immutability当你搞懂不可变性后,immutable.js对于你就是小菜一碟了。在 JavaScript 中，字符串 的值是 不可变的，这意味着一旦字符串被创建就不能被改变。例如，下面的代码：var myStr = &quot;Bob&quot;;myStr[0] = “J”;是不会把变量 myStr 的值改变成 “Job” 的，因为变量 myStr 是不可变的。注意，这 并不 意味着 myStr 永远不能被改变，只是字符串字面量 string literal 的各个字符不能被改变。改变 myStr 中的唯一方法是重新给它赋一个值，就像这样：var myStr = &quot;Bob&quot;;myStr = &quot;Job&quot;; Word Blanks现在，我们来用字符串的相关知识实现一个造句函数。通过使用提供的变量参数：名词myNoun、形容词myAdjective、动词myVerb、副词myAdverb，来创建一个新的句子 result。请注意，在英文中，句中的单词是必须用空格来分隔的举个例子，如果名词为 “dog”，形容词为 “big”，动词为 “run”，副词为”quickly”，那么函数返回值为 “dog big run quickly” 就是没问题的此外，为了句子通顺，你可以在包含所有传入单词的前提下自己添加一些其他单词。对于上面的例子，函数返回值为 “That big brown dog just run quickly” 也是没问题的 Store Multiple Values in one Variable using JavaScript Arrays使用数组，我们可以在一个地方存储多个数据。你以左方括号[开始定义一个数组，以右方括号]结束定义，并把每个条目之间用逗号隔开，就像这样：var sandwich = [“peanut butter”, “jelly”, “bread”]。任务创建一个包含 字符串 和 数字 的数组 myArray。 你也可以在数组中包含其他数组，就像这样: [[“Bulls”, 23], [“White Sox”, 45]]。这被称为一个 多维数组。 一个简单的方法将数据追加到一个数组的末尾是通过 push() 函数。 改变数组中数据的另一种方法是用 .pop() 函数。.pop() 函数用来”抛出”一个数组末尾的值。我们可以把这个”抛出”的值赋给一个变量存储起来。数组中任何类型的条目（数值，字符串，甚至是数组）可以被”抛出来” 。举个例子, 对于这段代码 var oneDown = [1, 4, 6].pop();现在 oneDown 的值为 6 ，数组变成了 [1, 4]。 Manipulate Arrays With shiftpop()函数用来移出数组中最后一个元素。如果想要移出第一个元素要怎么办呢？这就是 .shift() 的用武之地。它的工作原理就像 .pop()，但它移除的是第一个元素，而不是最后一个。 你不仅可以 shift（移出）数组中的第一个元素，你也可以 unshift（移入）一个元素到数组的头部。.unshift() 函数用起来就像 .push() 函数一样, 但不是在数组的末尾添加元素，而是在数组的头部添加元素。 Write Reusable JavaScript with Functions在 JavaScript 中，我们可以把代码的重复部分抽取出来，放到一个函数（functions）中。这是一个函数（function）的例子： function functionName() { console.log(&quot;Hello World&quot;); }调用函数functionName();每次调用函数时它会打印出消息的”Hello World”到开发的控制台上。所有的大括号之间的代码将在每次函数调用时执行。 函数的参数parameters在函数中充当占位符(也叫形参)的作用，参数可以为一个或多个。调用一个函数时所传入的参数为实参，实参决定着形参真正的值。简单理解：形参即形式、实参即内容。这是带有两个参数的函数， param1 和 param2： function testFun(param1, param2) { console.log(param1, param2); }接着我们调用 testFun：testFun(“Hello”, “World”);我们传递了两个参数， “Hello” 和 “World”。在函数内部，param1 等于”Hello”，param2 等于”World”。请注意，testFun 函数可以多次调用，每次调用时传递的参数会决定形参的实际值。 Global Scope and Functions在 JavaScript 中， 作用域 涉及到变量的作用范围。在函数外定义的变量具有 全局 作用域。这意味着，具有全局作用域的变量可以在代码的任何地方被调用。这些没有使用var关键字定义的变量，会被自动创建在全局作用域中，形成全局变量。当在代码其他地方无意间定义了一个变量，刚好变量名与全局变量相同，这时会产生意想不到的后果。因此你应该总是使用var关键字来声明你的变量。 在一个函数内声明的变量，以及该函数的参数都是局部变量，意味着它们只在该函数内可见。这是在函数 myTest内声明局部变量loc 的最佳例子： function myTest() { var loc = &quot;foo&quot;; console.log(loc); } myTest(); // &quot;foo&quot; console.log(loc); // &quot;undefined&quot;在函数外，loc 是未定义的。 一个程序中有可能具有相同名称的 局部 变量 和 全局 变量。在这种情况下，局部 变量将会优先于 全局 变量。下面为例： var someVar = &quot;Hat&quot;; function myFun() { var someVar = &quot;Head&quot;; return someVar; }函数 myFun 将会返回 “Head”，因为 局部变量 优先级更高。 Stand in Line在计算机科学中 队列（queue）是一个抽象的数据结构，队列中的条目都是有秩序的。新的条目会被加到 队列 的末尾，旧的条目会从 队列 的头部被移出。写一个函数 queue ，用一个数组arr和一个数字item作为参数。数字item添加到数组的结尾，然后移出数组的第一个元素，最后队列函数应该返回被删除的元素。 Understanding Boolean Values另一种数据类型是布尔（Boolean）。布尔 值要么是true 要么是false。它非常像电路开关， true是”开”，false 是”关”。这两种状态是互斥的。注意Boolean 值绝不会写作被引号包裹起来的形式。字符串的 “true” 和 “false” 不是 布尔值，在 JavaScript 中也没有特殊含义。 Comparison with the Strict Equality Operator严格相等运算符（===）是相对于相等操作符（==）的一种操作符。与相等操作符不同的是，它会同时比较元素的值和 数据类型。举个例子3 === 3 // true3 === ‘3’ // false3 是一个数字类型的，而’3’ 是一个字符类型的，所以3不全等于’3’。 严格不相等运算符（!==）与全等运算符是相反的。这意味着严格不相等并返回 false 的地方，用严格相等运算符会返回 true，反之亦然。严格相等运算符不会转换值的数据类型。 使用大于运算符（&gt;）来比较两个数字。如果大于运算符左边的数字大于右边的数字，将会返回 true。否则，它返回 false。与相等运算符一样，大于运算符在比较的时候，会转换值的数据类型。 如果你有非常多的选项需要选择，可以使用switch语句。根据不同的参数值会匹配上不同的case分支，语句会从第一个匹配的case分支开始执行，直到碰到break就结束。这是一个伪代码案例： switch (num) { case value1: statement1; break; case value2: statement2; break; ... case valueN: statementN; break; }测试case 值使用严格相等运算符进行比较，break关键字告诉javascript停止执行语句。如果没有break关键字，下一个语句会继续执行。 Adding a default option in Switch statements在switch 语句中你可能无法用case来指定所有情况，这时你可以添加default语句。当再也找不到case匹配的时候default语句会执行，非常类似于if/else组合中的else语句。default语句应该是最后一个case。 switch (num) { case value1: statement1; break; case value2: statement2; break; ... default: defaultStatement; } Build JavaScript Objects你之前可能听说过对象 object 。对象和数组很相似，数组是通过索引来访问和修改数据，对象是通过属性来访问和修改数据的。这是一个示例对象： var cat = { &quot;name&quot;: &quot;Whiskers&quot;, &quot;legs&quot;: 4, &quot;tails&quot;: 1, &quot;enemies&quot;: [&quot;Water&quot;, &quot;Dogs&quot;] };对象适合用来存储结构化数据，就和真实世界的对象一模一样，比如一只猫。 Accessing Objects Properties with the Dot Operator有两种方式访问对象属性，一个是点操作符(.)，一个是中括号操作符([])。当你知道属性的名称的时候，使用点操作符。这是一个使用点操作符读取对象属性的例子： var myObj = { prop1: &quot;val1&quot;, prop2: &quot;val2&quot; }; var prop1val = myObj.prop1; // val1 var prop2val = myObj.prop2; // val2任务通过点操作符读取对象testObj，把hat的属性值赋给变量hatValue，把shirt的属性值赋给shirtValue。 Accessing Objects Properties with Bracket Notation第二种访问对象的方式就是中括号操作符([])，如果你想访问的属性的名称有一个空格，这时你只能使用中括号操作符([])。这是一个使用中括号操作符([])读取对象属性的例子： var myObj = { &quot;Space Name&quot;: &quot;Kirk&quot;, &quot;More Space&quot;: &quot;Spock&quot; }; myObj[&quot;Space Name&quot;]; // Kirk myObj[&apos;More Space&apos;]; // Spock提示：属性名称中如果有空格，必须把属性名称用单引号或双引号包裹起来。 中括号操作符的另一个使用方式是用变量来访问一个属性。当你需要遍历对象的属性列表或查表时，这种方式极为有用。 这有一个使用变量来访问属性的例子： var someProp = &quot;propName&quot;; var myObj = { propName: &quot;Some Value&quot; } myObj[someProp]; // &quot;Some Value&quot;还有更多： var myDog = &quot;Hunter&quot;; var dogs = { Fido: &quot;Mutt&quot;, Hunter: &quot;Doberman&quot;, Snoopie: &quot;Beagle&quot; } var breed = dogs[myDog]; console.log(breed)// &quot;Doberman&quot;提示：当我们通过变量名访问属性的时候，不需要给变量名包裹引号。因为实际上我们使用的是变量的值，而不是变量的名称。 添加可以直接添加我们同样可以删除对象的属性，例如：delete ourDog.bark; 对象和字典一样，可以用来存储键/值对。如果你的数据跟对象一样，你可以用对象来查找你想要的值，而不是使用switch或if/else语句。当你知道你的输入数据在某个范围时，这种查找方式极为有效。这是简单的反向字母表： var alpha = { 1:&quot;Z&quot;, 2:&quot;Y&quot;, 3:&quot;X&quot;, 4:&quot;W&quot;, ... 24:&quot;C&quot;, 25:&quot;B&quot;, 26:&quot;A&quot; }; alpha[2]; // &quot;Y&quot; alpha[24]; // &quot;C&quot; var value = 2; alpha[value]; // &quot;Y&quot; Testing Objects for Properties有时检查一个对象属性是否存在是非常有用的，我们可以用.hasOwnProperty(propname)方法来检查对象是否有该属性。如果有返回true，反之返回 false。举例： var myObj = { top: &quot;hat&quot;, bottom: &quot;pants&quot; }; myObj.hasOwnProperty(&quot;top&quot;); // true myObj.hasOwnProperty(&quot;middle&quot;); // false任务修改函数checkObj检查myObj 是否有checkProp属性，如果属性存在，返回属性对应的值，如果不存在，返回 &quot;Not Found&quot;。注意：如果你需要通过变量来访问对象的属性值，请用中括号操作符，点操作符不支持变量。 Introducing JavaScript Object Notation JSONJavaScript Object Notation 简称 JSON，它使用JavaScript对象的格式来存储数据。JSON是灵活的，因为它允许 数据结构 是 字符串，数字，布尔值，字符串，和 对象 的任意组合。这里是一个JSON对象的示例： var ourMusic = [ { &quot;artist&quot;: &quot;Daft Punk&quot;, &quot;title&quot;: &quot;Homework&quot;, &quot;release_year&quot;: 1997, &quot;formats&quot;: [ &quot;CD&quot;, &quot;Cassette&quot;, &quot;LP&quot; ], &quot;gold&quot;: true } ];这是一个对象数组，并且对象有各种关于专辑的 详细信息。它也有一个嵌套的 formats 的数组。附加专辑记录可以被添加到数组的最上层。提示数组中有多个 JSON 对象的时候，对象与对象之间要用逗号隔开。 Accessing Nested Objects in JSON通过串联起来的点操作符或中括号操作符来访问JSON对象的嵌套属性。下面是一个嵌套的JSON对象： var ourStorage = { &quot;desk&quot;: { &quot;drawer&quot;: &quot;stapler&quot; }, &quot;cabinet&quot;: { &quot;top drawer&quot;: { &quot;folder1&quot;: &quot;a file&quot;, &quot;folder2&quot;: &quot;secrets&quot; }, &quot;bottom drawer&quot;: &quot;soda&quot; } } ourStorage.cabinet[&quot;top drawer&quot;].folder2; // &quot;secrets&quot; ourStorage.desk.drawer; // &quot;stapler&quot; 正如我们在前面的例子所见，JSON对象可以嵌套对象和数组。与访问嵌套对象一样，用中括号操作符同样可以访问嵌套数组。下面是如何访问嵌套数组的例子： var ourPets = { &quot;cats&quot;: [ &quot;Meowzer&quot;, &quot;Fluffy&quot;, &quot;Kit-Cat&quot; ], &quot;dogs&quot;: [ &quot;Spot&quot;, &quot;Bowser&quot;, &quot;Frankie&quot; ] }; ourPets.cats[1]; // &quot;Fluffy&quot; ourPets.dogs[0]; // &quot;Spot&quot; Iterate with JavaScript For Loops一个条件语句只能执行一次代码，而一个循环语句可以多次执行代码。JavaScript 中最常见的循环就是”for循环”。for循环中的三个表达式用分号隔开：for ([初始化]; [条件判断]; [计数器])初始化语句只会在执行循环开始之前执行一次。它通常用于定义和设置你的循环变量。条件判断语句会在每一轮循环的开始执行，只要条件判断为 true 就会继续执行循环。当条件为 false的时候，循环将停止执行。这意味着，如果条件在一开始就为 false，这个循环将不会执行。计数器是在每一轮循环结束时执行，通常用于递增或递减。在下面的例子中，先初始化i = 0，条件 i &lt; 5 为真，进入第一次循环，执行大括号里的代码，第一次循环结束。递增i的值，条件判断，就这样依次执行下去，直到条件判断为假，整个循环结束。 var ourArray = []; for (var i = 0; i &lt; 5; i++) { ourArray.push(i); }最终 ourArray 的值为 [0,1,2,3,4]. Nesting For Loops如果你有一个二维数组，可以使用相同的逻辑，先遍历外面的数组，再遍历里面的子数组。下面是一个例子： var arr = [ [1,2], [3,4], [5,6] ]; for (var i=0; i &lt; arr.length; i++) { for (var j=0; j &lt; arr[i].length; j++) { console.log(arr[i][j]); } }一次输出 arr 中的每个子元素。提示，对于内部循环，我们可以通过 arr[i] 的 .length 来获得子数组的长度，因为 arr[i] 的本身就是一个数组。 Generate Random Fractions with JavaScript计算机的行为只有两种：确定性和随机性。当你一步步地闯关来到这里就是确定行为，当你随意点了个链接就来到这里就是随机行为。而随机数最适合用来创建这种随机行为。Math.random()用来生成一个在0(包括0)到1(不包括1)之间的随机小数，因此Math.random()可能返回0但绝不会返回1。提示随后的函数都会在return执行前调用，所以我们可以直接返回Math.random()的值。任务更改myFunction 来生成一个随机数取代 0。 Sift through Text with Regular ExpressionsRegular expressions 正则表达式被用来根据某种匹配模式来寻找strings中的某些单词。 举例：如果我们想要找到字符串The dog chased the cat中单词 the，我们可以使用下面的正则表达式: /the/gi我们可以把这个正则表达式分成几段：/ 是这个正则表达式的头部the 是我们想要匹配的模式/ 是这个正则表达式的尾部g 代表着 global(全局)，意味着返回所有的匹配而不仅仅是第一个。i 代表着忽略大小写，意思是当我们寻找匹配的字符串的时候忽略掉字母的大小写。 Find Numbers with Regular Expressions我们可以在正则表达式中使用特殊选择器来选取特殊类型的值。特殊选择器中的一种就是数字选择器\\d，意思是被用来获取一个字符串的数字。在JavaScript中, 数字选择器类似于: /\\d/g。在选择器后面添加一个加号标记(+)，例如：/\\d+/g，它允许这个正则表达式匹配一个或更多数字。尾部的g是’global’的简写，意思是允许这个正则表达式 找到所有的匹配而不是仅仅找到第一个匹配。","link":"/2019/05/05/FCC-Front%20End-Basic%20Javascript-%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"},{"title":"知识：\"Why\"和未串好的项链","text":"“规律” 这个世界的发展不是随机的。目前的我认为，世界的演变是由一系列的因果组成的。就像函数的映射，原因映射到结果。而目前呈现的状态是由无数的参数经过某种映射关系得到的结果。计算理论告诉我，由一个状态变为另一个状态，需要有一个转移函数。那么世界当前的状态，可能是由一个接受前一个状态的转移函数通过计算而得到的。 &nbsp; 或许存在一个答案，或者一个公式，是宇宙的运行的依据，或者那种东西可以称之为”道”。而这个道，人类还没有完全抓住，完全理解。而道本身从何而来，为何产生，那就是更高阶的问题，更不可能回答。”道”就是宇宙的转移函数。 &nbsp; 而我之所以是我，没有变成其他的样子，没有思考到别的东西，是由这个规律决定的，或者可以说，从出生，甚至出生之前的时间，都决定了我的存在。我认为是有更高的意志无形地在统治这个世界，同时也统治着我，但是这种统治我无法感知， 也无法证明它的存在。很多时候，我以为是我自己的思考，主观意识在决定我的行动，但其实我现在的状态可能也只是宇宙的那个终极的公式计算出来的产物。 &nbsp; 按照这种想法，所有的一切都不需要感到奇怪，包括阴暗的、变态的、丑陋的、邪恶的一切，因为所有的东西都是”合理”的，也就是说，终极函数计算出的结果，是准确的。 &nbsp; “好奇心” 人类的美妙之处，在于好奇心。我们人类有源源不断的好奇心，这让我们去思考，我们看到苹果掉下来，看到日月星辰的变化，看到高高低低的豌豆，但我们没有忽略它们。我们提出了很多很多的”为什么”，而同时也不断回答着为什么。 &nbsp; 科学的发展，就像是无数好奇心旺盛的人类在试图破解那个统治世界的”规律”。只是那个规律太大，太复杂，于是我们把它不断拆解、细分，分出不同的学科和领域，在领域里，甚至还加上很多的限定。靠着实验和现象，或者猜想和假设，我们推理出很多适用在小范围内的规律。 &nbsp; 人类科学家们就像是一群裁缝，世界的”规律”就像是一串完美又巨大的项链，而为了完成这串项链，目前科学家的工作，仅仅是将找到的珠子进行了排列。他们发现有些珠子之间还缺少着很多颗珠子，因此串珠子的工作根本无法开始。 &nbsp; 这是一项艰巨的工作，好在我们还有”好奇心”，向未知发问的能力我们不会丧失，即使越来越多的人失去，但火种还在， 尽管是微弱的光，我认为光还是在。 &nbsp; “存在” 我记得大概是五岁的时候，我突然对这个世界的存在产生了怀疑。为什么我能看见所有的颜色；为什么我能听见妈妈的声音或者电视机里传来的声音；为什么我会有意识，为什么我会存在。这种感觉给我带来一种超脱感和异常感。然而我慢慢地接受了，也就再也没有想过这样的问题。 &nbsp; 而随着年龄的增大，”为什么我会存在”这种问题，逐步转变为，”我存在是为了什么。” 我曾经的想法是，存在的意义在于体验。我所经历的一切都可以被称之为体验。但是这个回答不太能让我满足，”体验”之后呢？ &nbsp; “体验”之后的东西太虚无了。我记得我在某个晚上突然想到，人是一个导管，苦乐流过，导管在这个过程中的颜色，形状都发生了改变，而最后，当时间河流停滞，我们这样的改变又有什么意义呢？仅仅如此吗？ &nbsp; “意义” 追求知识的人们是在干什么呢？探索答案的人们是在干什么呢？我们人类是要干什么呀？我们存在于此是要为什么呀？ &nbsp; 是为了想要学习从未认识到的东西，是为了解答所有内心深处的”为什么”，是为了满足我们最原初的好奇心，是为了最终能够串起那串代表着世界的终极规律的项链。因此，存储在数据库的所有论文，所有的书籍，所有用英文用中文用各种各样的语言写成的东西，所有的信息，所有能被数据保存下来的东西，都是排列好的小部分珠子。 &nbsp; 我们想要弄懂这个宇宙运行的规律。 &nbsp; 弄懂这个世界。 &nbsp; 我记得的大学里最美的一个场景，就是我走在一教A的走廊，当时两边的教室里都在上课，只言片语间，我仿佛置身于一条河流，不由自主地感觉到幸福和平静。尽管我不清楚每一间教室里讲的具体内容，但是我看见了那些前人所发现并排列好的珠子闪烁的光彩。 &nbsp; 如果从很大的层面来看，现在的我认为，人类的意义在于发现这个世界的规律。而对于个体来说，能够做的事情就是在串珠子这项工作中，再进行一些珠子的排列，这或许就是所谓”意义”。 &nbsp; “科学” 什么是科学？先前我说，这个世界是存在一个终极规律的，而科学就是发现这个终极规律的子集的过程。 &nbsp; 如果细分来说，科学又分为自然科学和人文科学。 &nbsp; 之前和LZX聊到科学的时候，我提到实验室学长分享的论文，有跟她说到终极规律这个问题。但是她说我们以为的因果关系很可能并不成立，我想到如果是自然科学依赖因果性推出的结论，很可能就根本不是正确的。而同时，对Humanities的短暂接触和阅读，也让我认同她说的，人文学科是建立在假设和猜想上的，它承认了它本身的主观性和不可靠。 &nbsp; 而某种程度上，我一直信仰的自然科学，或许根本就是一种宗教也不一定。依靠现想和推理产生的理论，正确率如我所想象的高吗？（这个问题我还没有想清楚，还是先读书叭） 而会不会还有一种可能，就是想得悲观一些，可能当我们终于串好了这串珠子，拿到上帝面前，去问他终极的规律究竟是什么的时候，他或许否认了终极规律的存在，或许答案就是一片混沌或是虚无的存在。（就像lulu之前讲过的上帝和科学家得故事，我们明白了事物的”为什么”，但是无法解答”为什么”本身的存在原因。） &nbsp; 不过我首先会认为这串珠子很难串得好啦。 &nbsp; 再说到人文学科，我现在觉得它的研究范畴和我曾经以为的有很大不同。文学理论研究者费尽心思地去研究某个作者，某部作品，绝不是什么”无用之学”，我认为是在研究人的思想，人的精神，人的本质的演变过程，看起来是在研究他人，实际上是在研究我们自己。如果说自然科学更多的是向外研究，那么人文社科其实是在对内，向内去探索。 &nbsp; “时间线” 周四学长分享的论文，是通过分析不同学生的学习规划（选的课、发的paper、参加的活动）以及最后的职业，当学生想要达到不同目标时能够基于之前的时间事件序列给出推荐的路线。 &nbsp; 每个人的时间事件序列就是一条线，然后沿着那条线往前，自然而然就会得到某种结果。这是”终极规律”决定的。然后我就想，如果真的能够把所有的人的时间线都收集起来，进行处理，是不是可能实现个人的最优时间线推荐呢？我想要达到这样的目标，那么我就按照这样的时间线去进行就好了？ &nbsp; 这听上去很理性，科学，计算机。所谓”人生路径推荐系统”这样的东西，或许真的有可能实现吧。不过要想实现这样的机器，还是需要弄懂”规律”，难就难在是要弄懂一些难以量化的、向内的、充满主观性的规律。（这已经是人文学科的范畴了，因此用主观的方法去研究，本身就很难统一发现的规律） &nbsp; “和解” 不过对于时间线的思考终究还是有它的意义。我感觉我终于慢慢地和自己和解了。 &nbsp; 由于实时性，我们能看见所有人在当下的状态，却不能知道他的整个时间线。看见了同时刻的人的优秀，十分浮躁。但是想想如果按照时间线的逻辑，我在我的时间线里本应该潜心输入的时候却在羡慕别人时间线他们的输出，反而没把自己的时间线做好。 &nbsp; 我时而想起高中。那个搞化竞眼睛发光的人，我再也没有在大学里看到那样的人，可能有些人的气质跟他相近，但也没有他那样的热情和执着；那是就很羡慕周围的同学，自己暗暗地躲在小角落里，或者去图书馆找书看；最开心的时候就是跟同桌严肃地讨论人生观价值观，而我也再没有在大学和周围人那么深入地探讨过无关情感的思考（现在比较严肃的是在讨论婚姻观、LGBT啥的）。 &nbsp; 但是我终于渐渐不因为自己菜而失落。尽管包含着对知识的热爱，但是也明白自己的能力可能找不到珠子。但是还是会把这个视为追求，努力去实现。 &nbsp; 世界仍是未知的，为了解答”why？”, 找到珠子，我们要掌握到尽可能多的已知的珠子。而终极规律是否存在，也是要等到我们基本上串完项链之后再说吧。 &nbsp; 其他 事实上，我觉得探索自己的内心和他人的关系，其实也是在找珠子，只不过那样的珠子没有被严肃地记录下来，但他们终究是智慧。 &nbsp; 比如说恋爱可能也是一种找珠子的过程，你在这一过程中不断地认识自己，你发现了适用于两个人范围之间的规律，但其实你并不会把它以理论形式记录下来，而是实实在在地运用于生活，这就很好。（我还是想谈恋爱，因为想找到那个珠子，所以想脱单是因为好奇心：） &nbsp; 但是当见识广了，找到想要发现的珠子所在的区域之后，这些生活上的小珠子带给我的好奇心，相比之下就没有那么大了。 &nbsp; 哎我竟然还有好多想写的，等我多读点书，应该就会又有不一样的思考吧，这时间段的思考先记录于此。","link":"/2019/05/02/%E7%9F%A5%E8%AF%86%EF%BC%9AWhy%E5%92%8C%E6%9C%AA%E4%B8%B2%E5%A5%BD%E7%9A%84%E9%A1%B9%E9%93%BE/"},{"title":"git总结","text":"最近不知为什么git desktop崩了，遂重新使用命令行，总结一下git的相关命令。 本地库管理 切换到工作目录 将文件xxx（也可以添加文件夹）添加到仓库git add xxx 将文件提交到仓库git commit -m &quot;关于此次commit的描述&quot; 查看当前状态git status 查看修改内容 git diff 查看更新日志 git log 新建远程库 在github上创建仓库 切换到工作目录并与本地的库关联git remote add origin git@github.com:michaelliao/learngit.git 把本地库的内容推到远程库上（之后可以不用写-u)git push -u origin master 分支当使用github协同工作，使用分支可以使工作更加整洁。 切分支开发git的分支可以看作指向当前结点的指针，HEAD指针始终指向文件的最新的地方。 分支的创建：git branch branch1 分支的切换：git checkout branch1 分支切换意味着，如果在该分支上产生的所有改动add或commit都将是在该分支下。 分支的合并一、本地多个不同分支的合并本地有多个分支时，在branch1分支下，使用git merge branch2就会将branch2合并到branch1分支。 二、远程分支和本地分支的合并git pull拉取远程分之后直接与本地分支进行合并，其作用相当于git fetch和git merge 但是远程和本地合并时较长涉及到一致性的问题。 1.如果本地分支已有未提交的修改，此时又需要pull，可使用如下命令： 1）用git add将需要隐藏的文件保存在暂存区 2）隐藏本地分支工作：git stash save &quot;message&quot; 3）执行git pull命令，将远程分支下拉下来，此时不会出现冲突情况 4）使用git stash list可查看有哪些stash。使用git stash show stash@{num}可以看到第num-1个stash了存储了那些内容,默认是0号存储。 5） 若要恢复原来的文件，可使用git stash pop命令恢复。该命令会将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash。 6）若隐藏的文件可丢弃，则可使用git stash drop stash@{$num}丢弃该文件的内容。 注意，使用git stash后，暂存区的所有文件都会被隐藏，意味着如果再次进行git add 暂存区是不会有东西的，使用git commit也是无法提交更新的，只有恢复后才能解除文件的隐藏。 三、某个分支的diverged当出现了Your branch and origin/master have diverged,and have...different commits each respectively 此时可使用git rebase origin/master将分叉的分支重新合并。","link":"/2019/10/11/git%E6%80%BB%E7%BB%93/"},{"title":"D3笔记","text":"loading data onto the page 123456waitSeconds=numSeconds=&gt;new Promise(resolve=&gt;{ const message=`${numSeconds} seconds have passed!`; setTimeout(()=&gt;resolve(message),numSeconds*1000);})waitSeconds(2).then(message=&gt;console.log(message)); 结果：等待两秒后显示 2 seconds have passed! ECMAScript 6 FeaturesHTML CSS SVGScalable Vector Graph 1import{select,arc} from 'd3' 12345678910111213141516const width=+svg.attr('width') //string转换为floatconst width=parseFloat(svg.attr('width'))const circle=svg.append('circle') .attr('fill','yellow') .attr('stroke','black')const g=svg.append('g') .attr('transform','translate(${width/2},${height/2})');const mouth=svg.append('path') .attr('d',acr()({ innerRadius:80, outerRadius:100, startAngle:Math.PI/2, endAngle:Math,PI*3/2 })); d3csv comma seperated value customizing axisd3.format() 函数","link":"/2020/04/03/D3%E7%AC%94%E8%AE%B0/"},{"title":"hexo的坑和新博客","text":"hexo给一篇文章加多个tagstags:[‘a’,’b’] Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/31/hexo%E7%9A%84%E5%9D%91%E5%92%8C%E6%96%B0%E5%8D%9A%E5%AE%A2/"},{"title":"【综述总结1】Analysis Methods in Neural Language Processing:A Survey","text":"行文结构论文进行综述时很善于从多个维度对工作进行分类，比如使用的方法、语言现象等。（作者也输出了一张表格、通过不同的维度归纳了相关的工作）。整体来说是按照不同角度下的方法进行综述，比如有一章专门写了自然语言处理中的可视化方法和衡量的难度性。同时最后将所有本文的结论写在了结语。 Section 1 Introduction对全文脉络进行梳理 Section 2 什么样的语言信息会被神经网络使用？阐述从三个方面回答这一问题（和小标题对应）： which method are used 使用什么方法 what kind of linguistic information is sought 什么信息 which objects in the neural network are being investigated 什么被观测 2.2 Linguistic Phenomena sentence length 句子长度 word position 单词位置 word presence 文字出现 simple word order 简单词序 morphological information 形态信息 syntactic information 句法信息 semantic information 语义信息 other phenomena Section 3 可视化方法和衡量可视化工作的难度性Section 4 用于细粒度评估的挑战集的编译datasets used for evaluating neural network models that diverge from the common average case evaluatio 分类数据集的依据： the task they seek to evaluate the linguistic phenomena they aim to study the language(s) they target their size their method of construction how performance is evaluated Section 5 对抗性例子的产生和使用、神经网络的弱点Section 6 解释模型预测的工作Section 7 其他不归于上述主题的方法引用他人工作的句式 see somebody for example They found … suggesting that In contrast, Somebody made some headway on this question. Somebody noted several key properties… conducted behavioral experiments 其他句式 enable them to draw conclusions about… synthesize a holistic picture from this diverse body of work Another theme that emerges in several studies is… Much recent work has focused on … … have gained renewed popularity in the NLP community. Most of the relevant analysis work is concerned with… Method … may shed new light on some of these questions. A long tradition in work on (domain) is to …","link":"/2020/04/30/%E7%BB%BC%E8%BF%B0%E6%80%BB%E7%BB%93/"},{"title":"【综述总结2】More Data,More Relations,More Context and More Openness:A Review and Outlook for Relation Extraction","text":"行文结构先关注于现有的工作，按照模型分类，其次探讨了关系提取的更多方向，主要是从数据量、学习表现、场景、领域四个方面，恰好和题目呼应；最后提出了其他的挑战。 Section 1 IntroductionRE: relation extraction Section 2 背景和现有的工作2.1 模式提取模型2.2 统计关系提取模型2.3 神经网络关系提取模型Section 3 RE的更多方向3.1 使用更多数据3.2 学习表现更有效3.3 在更复杂的场景中实现3.4 面向更开放的领域Section 4 其他挑战4.1 从文本或实体名中学习4.2关系提取数据集","link":"/2020/05/02/%E7%BB%BC%E8%BF%B0%E6%80%BB%E7%BB%93-2/"},{"title":"一个解决word页码错乱的小方法","text":"说实话，我常常因为word多此一举的方便用户而感到困扰。 比如拿到了一个页码错乱的文档模板，然后强迫症的我页码绝对不能错一个。 那么如果出现了这样恐怖的情况:文档页码在某一页开始一直往下都相同的话，其实是因为word看见的文档并不和你看见的一样，如果一个节没有结束的话，那么word就默认这一页还没有结束，可以理解为word看见的文档按照节来说实际上是一个不知道多长的羊皮卷。 通常如果出现页码相同的情况，可以双击页码并注意看导航栏里是否勾选了链接到前一节。我们看字面意思就能猜到，链接到前一节就指的是前后两个页面(不一定是你看到的页面，而是word认为的页面，总之）它们被绑定在一起了，修改一个另一个也会被更改。如果你发现勾选了这项的话，把它取消。我们不需要自作多情的链接。 但是还有一种情况是你发现链接到前一节没有被勾选，但页码也还是从某一页往下相同，那么就是因为word把”节“理解成了”页“，对于未完成的节，它是不会变换页码的。所以，你要做的就是告诉word这一页已经结束了。 那么具体的方法如下： 1.光标移动到相同页面中的第一张的最末尾，点击布局-&gt; 分隔符，选择下一页，就会在该页插入分节符（下一页） 2.选中第二页的页码，就会发现此时会显示勾选了链接到前一节，取消它 3.正确地命名页码 4.如此往复直到问题解决 不知道这个方法是不是正确，总之页码错乱问题是能够解决了，但是随之而来的是新的问题，自动目录并不能识别到对应的页码，还好自动页码可以手动改页码。 结尾也不知道要说我是该去学习一下Word呢，还是高喊”Latex真香“, 那就这样吧。","link":"/2020/05/20/%E4%B8%80%E4%B8%AA%E8%A7%A3%E5%86%B3word%E9%A1%B5%E7%A0%81%E9%94%99%E4%B9%B1%E7%9A%84%E5%B0%8F%E6%96%B9%E6%B3%95/"},{"title":"关于语法分析","text":"这将是一个非常口语化的总结，因为这就是我口述的总结。 语法分析过程主要包括两种方法：自底向上的语法分析和自顶向下的语法分析。其中，“底”指的就是原始串，而“顶”指的是开始符号。分析的目的就是确定某一个确定的字符串是否属于文法描述的语言。 而这些分析方法，最终都是要让串形成对应的语法分析树，因此它们将一个判定问题，转化成了生成语法分析树的过程。 First集和Follow集First集和Follow集应该是对于任意的文法都是能够确定的。 文法中的任意文法符号串都是有First集的，First集相当于这个文法符号串能推出的串中最左侧的终结符的集合。First集可以包含$\\epsilon$。 求First集的规则： 把所有的终结符语法规则列出来（我感觉First集求的时候不能有或？还是也可以） 如果X是终结符或者$\\epsilon$,$First(X)={X}$ 如果X是非终结符，对每个产生式$X-&gt;X_1X_2…X_n$,$First(X_1)$是$First(X)$的子集。 如果有$X_1X_2…X_i\\Rightarrow\\epsilon(i&lt;n)$,那么$First(X_{i+1})$是$First(X)$的子集。 Follow集能够让一个非终结符消失（推出空），就是说Follow是确定当某一个非终结符后面出现了哪些终结符的时候，我们需要用推出空这个产生式。 求Follow集的规则： 1.先将$放入Follow(S)中，S为开始字符。(构建LL(1)分析表的时候，如果有$S\\Rightarrow\\epsilon$,那么就可以写在[S,$]里，表示如果接受的是一个空串，就可以用这个产生式) 2.如果存在产生式$A\\rightarrow\\alpha B\\beta$,那么求解Follow(B)的时候，要将$First(B)$中除了$\\epsilon$所有的元素都加入Follow(B)。$\\beta$可包含终结符或非终结符。 3.产生式右侧被推导出之后，左侧的Follow集就是右侧最右（需要考虑右侧是否为空，若为空就不断考虑向左移动的符号）的非终结符的Follow集的子集。 【如果存在产生式$A\\rightarrow\\alpha B\\beta$,且$\\beta$可空（或者说B的First集包含$\\epsilon$)，那么$Follow(B)\\Leftarrow Follow(A)$】 因为我们确定某个非终结符的Follow集，都是通过它在右侧才能确定的，因此我们不需要考虑那些右侧全是终结符的产生式。 LL(1)分析表做的是这件事：横轴是预测的下一个字符，然后当前的栈顶的非终结符已知，那么要通过哪一个产生式能够最终推出预测的下一个字符。所以我们需要通过计算First集和Follow集来确定LL(1)分析表。 自顶向下的语法分析从开始符号最终到实际的字符串，自顶向下中主要分为回溯分析程序和预测分析程序。我们主要学了两种预测分析方法：递归下降和LL(1)。 为何叫“预测分析”，我们可以这么理解：首先，自顶向下分析方法的基础就是将字符串看成输入串，就是说从开始到结束，我们可以认为是逐步读取这个串的，因此字符之间有了先后被读取的，那么我们构建语法分析树也就是一个先根次序创建树的过程，我们也可以说自顶向下分析就是要找到对应串的最左推导。因此预测分析首先是要求给定的文法中没有左因子、左递归，文法不能是二义性的，其次预测分析需要看文法的下一个字符，也就是下一个输出符号，所以我们称之为“预测”。 回溯分析程序预测分析程序递归下降改写为$EBNF$(消除左递归、去除左因子) LL(1)第一个L表示从左向右扫描输入，第二个L表示最左推导，1表示每一步中只需要向前看一个输入符号来决定语法分析动作。 预测分析表的构建 $LL(1)$构建预测分析表的步骤： $First(\\alpha)$中的每个记号$s$，都将$A\\rightarrow\\alpha$添加至$M[A,s]$中。 $\\alpha$可空的话，对$Follow(A)$中的每一个元素$k$，将$A\\rightarrow\\alpha$添加到$M[A,k]$中。 如果$M[A,\\alpha]$没有产生式的话，就将其设置为$error$。 LL(1)文法一个文法若满足以下条件，则该文法就是LL(1)文法： 在每个产生式$A\\rightarrow{\\alpha}_1 |{\\alpha}_2⋯|{\\alpha}_n$中，对于所有的i和j:$1≤i, j≤n, i≠j$，$First(α_i )∩First(α_j )$为空。（若不为空，假设有一个相同元素$k$,那么在$M[A,k]$就会加入两个产生式：$A\\rightarrow{\\alpha}_i$和$A\\rightarrow{\\alpha}_j$) 若对于非终结符A可空，那么$First(A)∩Follow(A)$为空。(若有相同元素k，根据分析表也会发现$M[A,k]$有两个产生式) 如果一个文法G，由它构造的LL(1)分析表中的每个子项最多只含有一个产生式，那么它就是LL(1)文法。 在LL(1)分析表中有两项产生式的文法不一定是二义性的文法，可能是有左递归的。 一个不是$LL(1)$的文法同样可以用$LL(1)$方法。 LL(1）方法对应的是非递归的预测分析器，显示维护栈结构，应该和计算理论里的下推自动机类似。下推自动机所定义的语言恰好就是上下文无关语言。 自底向上的语法分析归约其实就是推导的反向操作。如果反向构造一个推导过程，那么就会是最右推导的。推导的方法是从记号串开始，使用产生式进行归约，期望得到开始符号，如果能够得到开始符号，那么这个字符串就是文法可以识别的语句。 两个动作：移进 shift和规约 reduce。 自底向下就是从输入串到开始符号的归约，归约的方向是从左到右，可以认为是最左归约，逆向的过程就是最右推导。 概念短语、直接短语和句柄短语就是在一个句型中对应的分析树，里以非终结符为根的子树的所有叶子节点构成的排列就是对于该非终结符的短语，如果子树只有两层，那么就是直接短语。最左侧的非终结符的子树对应的短语就是句柄。 句柄的定义：如果$S\\Rightarrow_{lm}^{*}\\alpha A\\omega \\Rightarrow_{lm} \\alpha \\beta \\omega$，A是输入串中最右的非终结符，则$\\beta$称为一个句柄。 句柄可以理解为一个归约点，可以允许解析器通过进一步的归约操作回到开始符号的位置。而实际上我们做的归约就是最左归约。 对于下列文法： $E\\rightarrow E+T|T$$T\\rightarrow T*F|F$$F\\rightarrow (E) |id$ 对于输入串$id*id$，从左到右是一个最左归约的过程。从左至右使用的产生式为： 产生式 $F\\rightarrow id$ 可行前缀LR(0)文法1.扩展文法。 在决定状态间的转移前，我们必须先加入一条扩展文法：$S\\rightarrow E$其中$S$是新的起始符号（start symbol）而E是原先的起始符号。这一做法是为了保证分析器能有一个唯一的起始状态。 2.列LR(0)项。 3.起始状态是所有点在最左侧的LR(0)项组成的封闭集。 LR(0)文法中L指的是从左到右 点号的左侧是已经读入的，点号的剩余是还没有读入的 SLR(1)文法 所以其实表示正则语言的有穷自动机和和表示上下文无关语言的下推自动机都算图灵机？ 所谓的规约 上下文无关语言的泵引理 正则表达式 正则语言 上下文无关语言 上下文文法 上下文有关语言 所有的正则语言都能被上下文无关文法表示。","link":"/2020/05/21/%E5%85%B3%E4%BA%8E%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"},{"title":"语法分析的例子整理","text":"$$E\\rightarrow E+T|T \\T\\rightarrow TF|F \\F\\rightarrow (E) |id$$扩展文法：$$E’\\rightarrow E \\E\\rightarrow E+T|T \\T\\rightarrow TF|F \\F\\rightarrow (E) |id$$ LR(0)项：$$E’\\rightarrow .E \\quad E’\\rightarrow E. \\E\\rightarrow .E+T \\quad E\\rightarrow E.+T \\\\quad E\\rightarrow E+.T \\quad E\\rightarrow E+T. \\E\\rightarrow .T \\quad E\\rightarrow T. \\T\\rightarrow .TF \\quad T\\rightarrow T.*F \\quad T\\rightarrow T.F \\quad T\\rightarrow T*F. \\T\\rightarrow .F \\quad T\\rightarrow F. \\F\\rightarrow .(E) \\quad F\\rightarrow (.E) \\quad F\\rightarrow (E.) \\quad F\\rightarrow (E). \\F\\rightarrow .id \\quad F\\rightarrow id.$$绘制LR(0)自动机：","link":"/2020/05/21/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%9A%84%E4%BE%8B%E5%AD%90%E6%95%B4%E7%90%86/"}],"tags":[{"name":"文本挖掘","slug":"文本挖掘","link":"/tags/%E6%96%87%E6%9C%AC%E6%8C%96%E6%8E%98/"},{"name":"主题建模","slug":"主题建模","link":"/tags/%E4%B8%BB%E9%A2%98%E5%BB%BA%E6%A8%A1/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"知其所以然","slug":"知其所以然","link":"/tags/%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6/"},{"name":"数字人文","slug":"数字人文","link":"/tags/%E6%95%B0%E5%AD%97%E4%BA%BA%E6%96%87/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"博客","slug":"博客","link":"/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"NLP","slug":"NLP","link":"/tags/NLP/"},{"name":"综述","slug":"综述","link":"/tags/%E7%BB%BC%E8%BF%B0/"},{"name":"编译原理","slug":"编译原理","link":"/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}],"categories":[]}